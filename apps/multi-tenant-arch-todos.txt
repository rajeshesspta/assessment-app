Matching

Represent as two lists with correct pairings. Define serialization (e.g., list of {prompt, targetId}) and scoring (full vs. partial credit).
Ordering/Ranking

Capture list of items with required order. Decide if scoring is binary or allows partial credit (Kendall tau, etc.).
Short Answer / Free Response

Store prompt + optional rubric keywords, link scoring to manual review or AI-assisted rubric evaluation.
Essay / Long Form

Similar to short answer but with length expectation and rubric metadata. Ensure attempts capture text blob and workflow for manual scoring.

Numeric Entry

Support exact value or range tolerance; include units metadata if needed.
Hotspot / Image Region

Store background image plus one or more correct polygons/regions. Define how attempts submit coordinates.
Drag-and-Drop

Schema for draggable tokens and drop zones (classification, labeling, sequencing). Determine scoring logic.
Scenario-Based / Coding Tasks

Likely separate module with attachments, evaluation scripts, or test harness metadata.
Each phase should include:

types.ts update
Validation + route changes
Persistence/migration updates
Scoring logic (where applicable)
Seeds/tests (unit + route)
Docs/readme entry



Implementation Plan

Role Hierarchy & Permissions

Add Super Admin → Tenant Admin → Content Author user flow docs (README + maybe docs/domain.md).
Model APIs/DB fields to associate users with roles (tenant admin, content author, learner) if not already tracked; ensure Super Admin can create tenants + delegate admins.
Tenant & User Provisioning

Extend provisioning CLI or routes so Super Admin can create tenants and seed a tenant admin record.
Expose tenant-admin API/CLI to invite content authors and learners; persist their role and cohort memberships.
Item & Assessment Management

Confirm items remain tenant-scoped but shared among that tenant’s content authors.
Adjust item repository/services if we need to record author ownership metadata while keeping shared visibility.
Ensure assessments store allowedAttempts (default 1), item references, and assignment targets (cohort IDs or individual learner IDs).
Cohorts & Assignment Flow

Create cohort entity (name, description, learner IDs, tenantId).
Add APIs for tenant admins/content authors to create/manage cohorts, add learners, and assign assessments to cohorts or specific learners.
When assigning, generate learner-specific assessment entries (or references) with attempt limit metadata.
Attempts & Learner Scope

Update attempt creation to enforce per-learner scoping and respect allowedAttempts.
Ensure responses remain tied to {tenantId, assessmentId, learnerId} and that learners can’t exceed the configured attempt count.
Add validation/tests for cohort-based assignments so only assigned learners can start attempts.
Documentation & Tests

Update README/module docs to reflect the clarified workflow (Super Admin creation, tenant admin responsibilities, cohort usage, attempt limits).
Add Vitest coverage around new APIs (tenant provisioning, cohort assignments, attempt limit enforcement).




multi-tenant - execution plan
==============================
Assessment Content Types
==============================

- [ ] Matching — represent as two lists with correct pairings. Need serialization (`{ prompt, targetId }[]`) plus scoring modes (full vs partial credit).
- [ ] Ordering / Ranking — capture ordered lists; evaluate if Kendall tau / partial credit is required.
- [ ] Short Answer / Free Response — persist prompt + rubric keywords; wire scoring to manual or AI-assisted flows.
- [ ] Essay / Long Form — extend short-answer schema with length expectations and rubric metadata; ensure attempts store large text payloads.
- [ ] Numeric Entry — support exact answers and tolerance ranges; include optional units metadata.
- [ ] Hotspot / Image Region — store base image + polygons, define answer serialization for coordinates.
- [ ] Drag-and-Drop — model token + zone schemas (classification, sequencing) and scoring logic.
- [ ] Scenario-Based / Coding Tasks — dedicate module for workspace templates, attachments, evaluation scripts.

Each content rollout must include:
- types.ts updates
- Validation + route changes
- Persistence/migrations
- Scoring logic (+ deferred scoring when needed)
- Seeds/tests (unit + route)
- Docs/README updates

==============================
Platform Implementation Checklist
==============================

**Role Hierarchy & Permissions**
- [ ] Document Super Admin → Tenant Admin → Content Author flows inside `docs/domain.md`.
- [ ] Ensure user provisioning APIs persist explicit role arrays; add audits for role promotion/demotion.

**Tenant & User Provisioning**
- [ ] CLI / API endpoint for Super Admins to create tenants and seed tenant admins (control plane will own the metadata; primary API still needs admin records).
- [ ] Tenant-admin API or CLI for inviting content authors + learners, persisting cohort memberships.

**Item & Assessment Management**
- [ ] Confirm item ownership metadata requirements (shared bank but track authorship when auditing changes).
- [ ] Keep `assessments.allowedAttempts` + assignment targets (cohort IDs or learner IDs) in sync with repositories + migrations.

**Cohorts & Assignment Flow**
- [ ] Create/manage cohort APIs (name, description, learner IDs, tenantId).
- [ ] Assignment endpoints that attach assessments to cohorts or individuals and hydrate learner attempt quotas.

**Attempts & Learner Scope**
- [x] Attempt creation enforces learner role + cohort membership + allowedAttempts (landed in attempts module).
- [ ] Add regression tests that cover “assigned but exhausted attempts” and “not assigned” scenarios per cohort.

**Documentation & Tests**
- [ ] Update READMEs/docs after each capability ships.
- [x] Maintain Vitest coverage for new APIs (current suite covers tenant registry + BFF loader).

==============================
Control Plane & BFF Integration
==============================

- [x] Control plane API (`apps/control-plane-api`) with SQLite/Cosmos stores, migrations, and `/control/tenant-bundle`.
- [ ] Control plane console (Vite/React) for CRUD + audit UI.
- [ ] Secret rotation workflow that updates Key Vault references and writes audit entries.
- [x] Consumer BFF polling hook (`CONTROL_PLANE_BASE_URL`, `CONTROL_PLANE_API_KEY`, `TENANT_CONFIG_REFRESH_MS`).
- [ ] Alerting/metrics for bundle staleness (`/control/health` + telemetry shipping to dashboards).
- [ ] Webhook/websocket push for tenant bundle updates (reduce polling latency).

**Control Plane Console Security**
- [x] Enforce two-step login between console ↔ proxy (basic credential + OTP challenge) with session cookies guarding `/api/*`.
- [x] Persist OTP challenge/audit events in SQLite (timestamp, actor, action, metadata) and expose log retrieval for compliance.
- [ ] Emit audit records for login, logout, impersonation, and tenant mutations; surface in console UI. _(login + logout covered; tenant mutations still pending UI work)_
- [x] Hash OTP secrets at rest, redact codes in logs, and enforce short-lived sessions with manual revoke support.

==============================
Multi-tenant BFF + Portal Plan
==============================

**Tenant Registry (control plane)**
- [x] Define tenant config schema + REST endpoints.
- [ ] Expose secret management + branding asset upload pathways.

**Runtime Config Loader**
- [x] BFF startup loads bundle + refreshes in background.
- [ ] Consider ETag support to reduce payloads once control plane emits them.

**Tenant-aware Auth**
- [ ] `/auth/switch-tenant` flow for multi-membership users.
- [ ] Enforce actor-role overrides against the tenant’s allowed roles (log + block unauthorized overrides).

**Per-tenant API Proxying**
- [x] Inject `x-tenant-id`, `x-api-key`, and role headers on headless calls.
- [ ] Prevent Super Admin headers from leaking into tenant-scoped requests (double-check middleware once switch-tenant lands).

**Branding & Feature Delivery**
- [x] `/config` returns branding + feature flags.
- [ ] CDN-backed asset pipeline for logos/favicons/backgrounds.

**Portal Boot Flow**
- [x] Boot flow fetches `/config` + `/auth/session` and themes accordingly.
- [ ] Tenant switcher UI for multi-membership accounts.

**Data Isolation & Premium Path**
- [x] Repositories filter by tenantId + logging tags requests.
- [ ] Document premium deployment flow leveraging control-plane bundle export.

**Testing & Rollout**
- [ ] Stage env with multiple tenants hitting control-plane-powered BFF.
- [ ] Feature flag gating for gradual rollout (shared stack first, then premium).

This checklist keeps headless agnostic, lets the shared BFF/portal serve many tenants safely, and still supports separate deployments for premium customers when needed.


Tenant DB Config & Secret Resolution
=====================================

- Problem: some tenants need tenant-specific persistence (Cosmos, remote SQL, or file-backed SQLite). These connection details are sensitive and must not be exposed in plaintext to arbitrary clients.
- Goal: surface per-tenant DB configuration from the Control Plane to trusted runtimes (headless) using secret references and a secure resolution flow.

Design principles
- Never place plaintext credentials in the public tenant bundle.
- Use secret refs (e.g., `secretRef: "kv://tenant-alpha/headless-db"`) in the bundle; trusted runtimes resolve the ref using a configured secret provider.
- Keep the bundle lightweight and idempotent; include `bundleVersion`/`updatedAt` for atomic swaps.

Minimal schema additions (control plane)
- `tenant.headless.db?: { provider: 'sqlite'|'cosmos'|'memory'|'postgres'; connectionStringRef?: string; filePattern?: string; options?: Record<string,string> }`
- Store `db_config_json` in tenant row; persist only refs, not secrets.

BFF behavior
- BFF loads the bundle and exposes `tenant.headless.db` to runtime code but does not resolve secret refs itself by default.
- Optionally the BFF can be configured to resolve secrets for downstream services (only with strict access control).

Headless runtime responsibilities
- Provide a pluggable secret resolver (env|vault|console-proxy) to turn `connectionStringRef` into usable credentials.
- On first tenant use, resolve secrets, initialize tenant DB client, cache the client, and surface health/metrics per-tenant.
- Support rotation: detect changed `updatedAt`/`bundleVersion`, re-resolve refs, and swap connections with graceful handover.

Operational & security notes
- Limit who can set/rotate `db` config in the Control Plane (Super Admin or mapped role).
- Audit every change to DB config and every secret resolution attempt in headless logs (do not log secret contents).
- Provide runbook for emergency rotation and rollback.

Implementation backlog (small, ordered)
- [ ] Schema: add `headless.db` to `apps/control-plane-api/src/tenant-schema.ts` and migrations.
- [ ] Repo: persist `db_config_json` in tenant rows and include it in bundle builder.
- [ ] Console: add Tenant Settings UI to edit `db` refs (Super Admin only) and link to secret manager instructions.
- [ ] BFF: expose `headless.db` in runtime types; optionally add a configurable secret resolver.
- [ ] Headless: implement secret-resolver interface, per-tenant DB client factory, and rotation support.
- [ ] Tests: unit tests for schema parsing, integration test that mocks secret resolver and verifies DB client initialization.
- [ ] Docs: update `docs/control-plane-plan.md` and README entries describing secret refs and resolution.

Next actionable steps (short-term, 2-4 dev days)
- [ ] Implement schema + repository persistence for `headless.db` (Step A).
- [ ] Update BFF runtime types to accept the new shape and surface it to runtime code (Step B).
- [ ] Add a basic secret resolver implementation in headless that reads from env for local dev (Step C).
- [ ] Add integration test for headless that uses env-backed resolver and in-memory SQLite.
- [ ] Control plane console: Persistence tab exposes a DB provider selector (SQLite, Cosmos, etc.) and reveals provider-specific refs/fields before saving.
- [ ] Headless/runtime wiring: consume the tenant-selected provider when instantiating repositories so storage choice actually steers data placement.


